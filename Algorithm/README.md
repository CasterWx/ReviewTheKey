# 算法习题

## 一.选择题

1. 二分搜索算法是利用（ A ）实现的算法。
    A、分治策略   B、动态规划法
    C、贪心法    D、回溯法

2. 下列不是动态规划算法基本步骤的是（ A ）。

    A、找出最优解的性质   B、构造最优解
    C、算出最优解   D、定义最优解

3. 最大效益优先是（ A ）的一搜索方式。

    A、分支界限法      B、动态规划法
    C、贪心法    D、回溯法
4. 在下列算法中有时找不到问题解的是（ B ）。

    A、蒙特卡罗算法    B、拉斯维加斯算法
    C、舍伍德算法   D、数值概率算法

5. 回溯法解旅行售货员问题时的解空间树是（ A ）。

    A、子集树   B、排列树
    C、深度优先生成树   D、广度优先生成树

6. 下列算法中通常以自底向上的方式求解最优解的是（ B ）。

    A、备忘录法 B、动态规划法
    C、贪心法   D、回溯法

7. 衡量一个算法好坏的标准是（ C ）。

    A 运行速度快 B 占用空间少
    C 时间复杂度低 D 代码短

8. 以下不可以使用分治法求解的是（ D ）。

    A 棋盘覆盖问题 B 选择问题
    C 归并排序 D 0/1背包问题

9. 实现循环赛日程表利用的算法是（ A ）。

    A、分治策略 B、动态规划法
    C、贪心法   D、回溯法

10. 下列随机算法中运行时有时候成功有时候失败的是（ C ）

    A 数值概率算法 B 舍伍德算法
    C 拉斯维加斯算法 D 蒙特卡罗算法

11. 下面不是分支界限法搜索方式的是（ D ）。

    A、广度优先 B、最小耗费优先
    C、最大效益优先 D、深度优先

12. 下列算法中通常以深度优先方式系统搜索问题解的是（ D ）。

    A、备忘录法 B、动态规划法
    C、贪心法   D、回溯法

13. 备忘录方法是那种算法的变形。（ B ）

    A、分治法   B、动态规划法
    C、贪心法   D、回溯法
14. 哈弗曼编码的贪心算法所需的计算时间为（ B ）。

    A、O（n2n） B、O（nlogn）
    C、O（2n）  D、O（n）
15. 分支限界法解最大团问题时，活结点表的组织形式是（ B ）。

    A、最小堆   B、最大堆
    C、栈   D、数组

16. 最长公共子序列算法利用的算法是（ B ）。

    A、分支界限法B、动态规划法
    C、贪心法   D、回溯法

17. 实现棋盘覆盖算法利用的算法是（ A ）。

    A、分治法   B、动态规划法
    C、贪心法   D、回溯法

18. 下面是贪心算法的基本要素的是（ C ）。

    A、重叠子问题   B、构造最优解
    C、贪心选择性质 D、定义最优解

19. 回溯法的效率不依赖于下列哪些因素（ D ）

    A.满足显约束的值的个数  B. 计算约束函数的时间  
    C. 计算限界函数的时间   定解空间的时间

20. 下面哪种函数是回溯法中为避免无效搜索采取的策略（ B ）

    A．递归函数 B.剪枝函数
    C.随机数函数    D.搜索函数

21. 下面关于NP问题说法正确的是（ B ）

    A NP问题都是不可能解决的问题
    B P类问题包含在NP类问题中
    C NP完全问题是P类问题的子集
    D NP类问题包含在P类问题中

22. 蒙特卡罗算法是（ B ）的一种。

    A、分支界限算法 B、概率算法
    C、贪心算法 D、回溯算法

23. 下列哪一种算法不是随机化算法（ C ）

    A. 蒙特卡罗算法 B. 拉斯维加斯算法
    C.动态规划算法  D.舍伍德算法

24. （ D ）是贪心算法与动态规划算法的共同点。

    A、重叠子问题   B、构造最优解
    C、贪心选择性质 D、最优子结构性质

25. 矩阵连乘问题的算法可由（ B ）设计实现。

    A、分支界限算法 B、动态规划算法
    C、贪心算法 D、回溯算法

26. 分支限界法解旅行售货员问题时，活结点表的组织形式是（ A ）。

    A、最小堆   B、最大堆
    C、栈   D、数组

27. Strassen矩阵乘法是利用（ A ）实现的算法。

    A、分治策略   B、动态规划法
    C、贪心法    D、回溯法

28. 使用分治法求解不需要满足的条件是（ A ）。

    A 子问题必须是一样的
    B 子问题不能够重复
    C 子问题的解可以合并
    D 原问题和子问题使用相同的方法解

29. 下面问题（ B ）不能使用贪心法解决。

    A 单源最短路径问题  B N皇后问题
    C 最小花费生成树问题    D 背包问题

30. 下列算法中不能解决0/1背包问题的是（ A ）

    A 贪心法 B 动态规划 C 回溯法 D 分支限界法

31. 回溯法搜索状态空间树是按照（ C ）的顺序。

    A 中序遍历 B 广度优先遍历
    C 深度优先遍历 D 层次优先遍历

32. 下列随机算法中运行时有时候成功有时候失败的是（ C ）

    A 数值概率算法 B 舍伍德算法
    C 拉斯维加斯算法 D 蒙特卡罗算法

33. 实现合并排序利用的算法是（ A ）。

    A、分治策略 B、动态规划法
    C、贪心法   D、回溯法

34. 下列是动态规划算法基本要素的是（ D ）。

    A、定义最优解   B、构造最优解
    C、算出最优解   D、子问题重叠性质

35. 下列算法中通常以自底向下的方式求解最优解的是（ B ）。

    A、分治法   B、动态规划法
    C、贪心法   D、回溯法

36. 采用广度优先策略搜索的算法是（ A ）。

    A、分支界限法   B、动态规划法
    C、贪心法   D、回溯法

37. 合并排序算法是利用（ A ）实现的算法。

    A、分治策略   B、动态规划法
    C、贪心法    D、回溯法

38. 在下列算法中得到的解未必正确的是（ B ）。

    A、蒙特卡罗算法    B、拉斯维加斯算法
    C、舍伍德算法   D、数值概率算法

39. 背包问题的贪心算法所需的计算时间为（ B ）

    A、O（n2n）     B、O（nlogn）
    C、O（2n）      D、O（n）

40. 实现大整数的乘法是利用的算法（ C ）。

    A、贪心法   B、动态规划法
    C、分治策略 D、回溯法

41. 0-1背包问题的回溯算法所需的计算时间为（ A ）

    A、O（n2n） B、O（nlogn）
    C、O（2n）  D、O（n）

42. 采用最大效益优先搜索方式的算法是（ A ）。

    A、分支界限法   B、动态规划法
    C、贪心法   D、回溯法

43. 贪心算法与动态规划算法的主要区别是（ B ）。

    A、最优子结构   B、贪心选择性质
    C、构造最优解   D、定义最优解

44. 实现最大子段和利用的算法是（ B ）。

    A、分治策略 B、动态规划法
    C、贪心法   D、回溯法

45. 优先队列式分支限界法选取扩展结点的原则是（ C ）。

    A、先进先出 B、后进先出
    C、结点的优先级 D、随机

46. 背包问题的贪心算法所需的计算时间为（ B ）。

    A、O（n2n） B、O（nlogn）
    C、O（2n）  D、O（n）

47. 广度优先是（ A ）的一搜索方式。

    A、分支界限法   B、动态规划法
    C、贪心法    D、回溯法

48. 舍伍德算法是（ B ）的一种。

    A、分支界限算法 B、概率算法
    C、贪心算法    D、回溯算法

49. 在下列算法中有时找不到问题解的是（ B ）。

    A、蒙特卡罗算法    B、拉斯维加斯算法   C、舍伍德算法   D、数值概率算法

50. 下列哪一种算法是随机化算法（ D ）

    A. 贪心算法 B. 回溯法
    C.动态规划算法  D.舍伍德算法

51. 一个问题可用动态规划算法或贪心算法求解的关键特征是问题的（ B ）。

    A、重叠子问题   B、最优子结构性质
    C、贪心选择性质 D、定义最优解

52. 采用贪心算法的最优装载问题的主要计算量在于将集装箱依其重量从小到大排序，故算法的时间复杂度为 (  B ) 。

    A、O（n2n） B、O（nlogn）
    C、O（2n）  D、O（n）

53. 以深度优先方式系统搜索问题解的算法称为 (  D )             。

    A、分支界限算法      B、概率算法
    C、贪心算法    D、回溯算法

54. 实现最长公共子序列利用的算法是（ B ）。

    A、分治策略 B、动态规划法
    C、贪心法   D、回溯法

## 二. 填空题 

1. 算法的复杂性有 `时间复杂性` 和  `空间复杂性`之分。

2. 程序是 `算法` 用某种程序设计语言的具体实现。

3. 算法的“确定性”指的是组成算法的每条 `指令` 是清晰的，无歧义的。

4. 矩阵连乘问题的算法可由  `动态规划`  设计实现。

5. 拉斯维加斯算法找到的解一定是  `正确解` 。

6. 算法是指解决问题的  `一种方法`  或  `一个过程`   。

7. 从分治法的一般设计模式可以看出，用它设计出的程序一般是  `递归算法`  。

8. 问题的  `最优子结构性质`  是该问题可用动态规划算法或贪心算法求解的关键特征。

9. 以深度优先方式系统搜索问题解的算法称为  `回溯法`  。

10. 数值概率算法常用于  `数值问题`  的求解。

11. 计算一个算法时间复杂度通常可以计算  `循环次数` 、`基本操作的频率` 或`计算步`。

12. 利用概率的性质计算近似值的随机算法是  数值概率算法 ，运行时以一定的概率得到正确解的随机算法是  `蒙特卡罗算法`。

14. 解决0/1背包问题可以使用动态规划、回溯法和分支限界法，其中不需要排序的是  `动态规划`  ，需要排序的是  `回溯法` ，  `分支限界法`  。

15. 使用回溯法进行状态空间树裁剪分支时一般有两个标准：约束条件和目标函数的界，N皇后问题和0/1背包问题正好是两种不同的类型，其中同时使用约束条件和目标函数的界进行裁剪的是  `0/1背包问题`  ，只使用约束条件进行裁剪的是  `N皇后问题`   。

16. 贪心选择性质  是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

17. 矩阵连乘问题的算法可由  `动态规划`  设计实现。

18. 拉斯维加斯算法找到的解一定是  `正确解` 。

19. 贪心算法的基本要素是  `贪心选择`  质和  `最优子结构`  性质 。

20. 动态规划算法的基本思想是将待求解问题分解成若干  `子问题` ，先求解  子问题  ，然后从这些  子问题 的解得到原问题的解。

21. 算法是由若干条指令组成的有穷序列，且要满足`输入`、 `输出` 、`确定性`和 `有限性`       四条性质。

22. 大整数乘积算法是用  `分治法`  来设计的。

23. 以广度优先或以最小耗费方式搜索问题解的算法称为  `分支限界法`  。

24. 舍伍德算法总能求得问题的  `一个解` 。

25. 贪心选择性质  是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

26. 快速排序算法是基于  `分治策略`  的一种排序算法。

27. 动态规划算法的两个基本要素是 `最优子结构 性质` 和  `重叠子问题`  性质 。

28. 回溯法是一种既带有  `系统性` 又带有  `跳跃性` 的搜索算法。 

29. 分支限界法主要有  `队列式（FIFO）` `分支限界法` 和  `优先队列式`  分支限界法。

30. 分支限界法是一种既带有  `系统性`  又带有  `跳跃性`  的搜索算法。

31. 回溯法搜索解空间树时，常用的两种剪枝函数为  `约束函数`  和  `限界函数`   。

32. 任何可用计算机求解的问题所需的时间都与其  `规模`  有关。

33. 快速排序算法的性能取决于  `划分的对称性`  。

## 三. 算法填空

#### 1.背包问题的贪心算法

```c
void Knapsack(int n,float M,float v[],float w[],float x[])
{
        Sort(n,v,w);
        int i;
        for (i=1;i<=n;i++) x[i]=0;
        float c=M;
        for (i=1;i<=n;i++) {
            if (w[i]>c) break;
            x[i]=1;
            c - =w[i];
        }
        if (i<=n)
            x[i]=c/w[i];
}
```

#### 2.最大子段和: 动态规划算法

```c
int MaxSum(int n, int a[])
{
    int sum=0, b=0；   //sum存储当前最大的b[j], b存储b[j]
    for(int j=1； j<=n； j++)  {  
        if (b>0)  b+= a[j] ;
        else  b=a[i];     //一旦某个区段和为负，则从下一个位置累和
        if(b>sum) sum=b;
    }
    return sum；
 }
```

#### 3.贪心算法求装载问题

```c
template<class Type>
void Loading(int x[],  Type w[], Type c, int n)
{
        int *t = new int [n+1];
        for (int i = 1; i <= n; i++) 
            x[i] = 0;
        for (int i = 1; i <= n && w[t[i]] <= c; i++){
            x[t[i]] = 1;
        }
}
```

#### 4.贪心算法求活动安排问题

```c
template<class Type>
void GreedySelector(int n, Type s[], Type f[], bool A[]){
        A[1]=true;
        int j=1;
        for (int i=2;i<=n;i++) {
            if (s[i]>=f[j]){  
                A[i]=true;
                j=i;
            }else A[i]=false;
        }
}
```

#### 5.快速排序

```c
template<class Type>
void QuickSort (Type a[], int p, int r)
{
      if (p<r) {
        int q=Partition(a,p,r);
        QuickSort (a,p,q-1); //对左半段排序
        QuickSort (a,q+1,r); //对右半段排序
        }
}
```

#### 6.排列问题

```c
Template <class Type>
void perm(Type list[],  int k, int m )
{   //产生[list[k:m]的所有排列
    if(k==m)
    {  //只剩下一个元素
        for (int i=0;i<=m;i++)
            cout<<list[i];
        cout<<endl;
    }
    else  //还有多个元素待排列，递归产生排列
        for (int i=k; i<=m; i++){
           swap(list[k]，list[i]);
           perm(list,k+1;m);
           swap(list[k],list[i]);
        }
  }
```

## 四. 问答题

1. 分治法的基本思想时将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归地解这些子问题，然后将各个子问题的解合并得到原问题的解。

2. 设计动态规划算法的主要步骤为：
   （1）找出最优解的性质，并刻划其结构特征。（2）递归地定义最优值。（3）以自底向上的方式计算出最优值。（4）根据计算最优值时得到的信息，构造最优解。

3. 分治法与动态规划法的相同点与不同点分别是什么？
    两者的相同点：将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
两者的不同点是：适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的。而用分治法求解的问题，经分解得到的子问题往往是互相独立的。

4. 分支限界法与回溯法的相同点与不同点分别是什么？
   相同点：都是一种在问题的解空间树T中搜索问题解的算法。
   不同点：（1）求解目标不同；（2）搜索方式不同；（3）对扩展结点的扩展方式不同； （4）存储空间的要求不同。

5. 用回溯法搜索子集树的算法为：

```c
void backtrack (int t) 
{
  if (t>n) output(x); 
    else
      for (int i=0;i<=1;i++) {
        x[t]=i; 
        if (constraint(t)&&bound(t)) backtrack(t+1); 
      }
}
```

6. 分治法所能解决的问题一般具有的几个特征是：
  （1）该问题的规模缩小到一定的程度就可以容易地解决； 
  （2）该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质; 
  （3）利用该问题分解出的子问题的解可以合并为该问题的解； 
  （4）原问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

7. 用分支限界法设计算法的步骤是：
(1)针对所给问题，定义问题的解空间（对解进行编码）；分
(2)确定易于搜索的解空间结构（按树或图组织解） ； 
    (3)以广度优先或以最小耗费（最大收益）优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

8. 常见的两种分支限界法的算法框架
   （1）队列式(FIFO)分支限界法：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。 （2）优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

9. 回溯法中常见的两类典型的解空间树是子集树和排列树。
    当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。这类子集树通常有2n个叶结点，遍历子集树需O(2n)计算时间 。
    当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。这类排列树通常有n!个叶结点。遍历排列树需要O(n!)计算时间。

10. 分支限界法的搜索策略是：      
在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展结点。为了有效地选择下一扩展结点，加速搜索的进程，在每一个活结点处，计算一个函数值（限界），并根据函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。

## 五. 算法题

1. 给定已按升序排好序的n个元素a[0:n-1]，现要在这n个元素中找出一特定元素x，返回其在数组中的位置，如果未找到返回-1。
   写出二分搜索的算法，并分析其时间复杂度。

```c
template<class Type> 
int BinarySearch(Type a[], const Type& x, int n)
{//在a[0:n]中搜索x，找到x时返回其在数组中的位置，否则返回-1
     Int left=0;  int  right=n-1; 
     While (left<=right){
        int middle=(left+right)/2; 
        if (x==a[middle]) return middle; 
        if (x>a[middle]) left=middle+1;
        else right=middle-1; 
      }
      Return -1; 
} 
```

时间复杂性为O(logn)

2. 利用分治算法写出合并排序的算法，并分析其时间复杂度

```c
void MergeSort(Type a[], int left, int right) 	
   {
      if (left<right) {//至少有2个元素
      int i=(left+right)/2;  //取中点
      mergeSort(a, left, i); 
      mergeSort(a, i+1, right); 
      merge(a, b, left, i, right);  //合并到数组b 
      copy(a, b, left, right);    //复制回数组a 
      }
   }
```

算法在最坏情况下的时间复杂度为O(nlogn)。

3. N皇后回溯法

```c
bool Queen::Place(int k)
{ //检查x[k]位置是否合法
  for (int j=1;j<k;j++)
    if ((abs(k-j)==abs(x[j]-x[k]))||(x[j]==x[k])) return false;
  return true;
} 
void Queen::Backtrack(int t)
{
  if (t>n) sum++;
  else    for (int i=1;i<=n;i++) {
      x[t]=i;
      if (   约束函数  ) Backtrack(t+1);
    }
}
```

4. 最大团问题

```c
void Clique::Backtrack(int i) // 计算最大团
{  if (i > n) { // 到达叶结点
      for (int j = 1; j <= n; j++) bestx[j] = x[j];
      bestn = cn;   return;}
 // 检查顶点 i 与当前团的连接
   int OK = 1; 
   for (int j = 1; j < i; j++)
      if (x[j] && a[i][j] == 0) {         // i与j不相连
         OK = 0;  break;}
   if (OK ) { // 进入左子树
      x[i] = 1;  cn++;
      Backtrack(i+1);
      x[i] = 0; cn--;  } 
  if (     cn + n - i > bestn       ) { // 进入右子树
      x[i] = 0;
      Backtrack(i+1);  }
}
```

5. 最长公共子序列问题

6. 哈弗曼编码算法
